<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.WebcamWindow API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.WebcamWindow</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from PyQt5 import QtGui
from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QVBoxLayout, QPushButton
from PyQt5.QtGui import QPixmap
import sys
import cv2
from PyQt5.QtCore import pyqtSignal, pyqtSlot, Qt, QThread
import PyQt5.QtCore as QtCore
import numpy as np
from Webcam import Webcam

class WebcamWindow(QWidget):

    &#34;&#34;&#34;
    The WebcamWindow class is responsible for displaying a webcam feed in a GUI.
    &#34;&#34;&#34;

    startbuttonSignal = QtCore.pyqtSignal()
    calbuttonSignal = QtCore.pyqtSignal()

    def __init__(self):
        super().__init__()
        self.setWindowTitle(&#34;Qt live label demo&#34;)
        self.disply_width = 640
        self.display_height = 480
        self.no_webcam_text = &#34;No webcams connected&#34;
        self.permission_text = &#34;By pressing this button, you give permission to access your webcam. No actual footage will be stored.&#34;

        #Creates a button asking the user for permission to access their webcam
        self.permission_button = QPushButton(self.permission_text) 
        self.permission_button.clicked.connect(self.permitWebcamAccess)
        self.permission_button.setFixedSize(640, 150)

        #Create the label that holds the image
        self.image_label = QLabel(self)
        self.image_label.resize(self.disply_width, self.display_height)
        self.textLabel = QLabel(&#39;Webcam&#39;)

        #Create a vertical box layout and add the two labels
        vbox = QVBoxLayout()
        vbox.addWidget(self.permission_button, alignment=Qt.AlignCenter)
        vbox.addWidget(self.image_label)
        
        #self.image_label.hide()
        self.image_label.setAlignment(Qt.AlignCenter)
        self.calibration_text = &#34;Start calibration&#34;
        self.calibration_button = QPushButton(self.calibration_text)
        self.calibration_button.setFixedSize(640, 50)
        self.calibration_button.clicked.connect(self.calibration_button_clicked)
        self.calibration_button.setDisabled(True)
        vbox.addWidget(self.calibration_button, alignment=Qt.AlignHCenter)

        self.return_text = &#34;Return to start menu&#34;
        self.return_button = QPushButton(self.return_text)
        self.return_button.setFixedSize(640, 50)
        self.return_button.clicked.connect(self.return_button_clicked)
        vbox.addWidget(self.return_button, alignment=Qt.AlignHCenter)
        self.setLayout(vbox)

        #Create the video capture thread
        self.thread = Webcam()

    def calibration_button_clicked(self):
        &#34;&#34;&#34;Emits a signal when the calibration button is clicked.&#34;&#34;&#34;
        self.calbuttonSignal.emit()

    def return_button_clicked(self):
        &#34;&#34;&#34;Emits a signal when the return button is clicked.&#34;&#34;&#34;
        self.startbuttonSignal.emit()

    def permitWebcamAccess(self):
        &#34;&#34;&#34;Starts recording if the user gives permission to access their webcam.&#34;&#34;&#34;
        self.permission_button.hide()
        if self.thread.noWebcams() == False:
            self.calibration_button.setEnabled(True)
            self.start_recording()
        else:
            self.image_label.setText(self.no_webcam_text)

    def start_recording(self):
        #Connect its signal to the update_image slot
        self.thread.change_pixmap_signal.connect(self.update_image)
        #Start the thread
        self.thread.start()

    def closeEvent(self, event):
        self.thread.stop()
        event.accept()

    @pyqtSlot(np.ndarray)
    def update_image(self, cv_img):
        &#34;&#34;&#34;Updates the image_label with a new opencv image&#34;&#34;&#34;
        qt_img = self.convert_cv_qt(cv_img)
        self.image_label.setPixmap(qt_img)
    
    def convert_cv_qt(self, cv_img):
        &#34;&#34;&#34;Convert from an opencv image to QPixmap&#34;&#34;&#34;
        rgb_image = cv2.cvtColor(cv_img, cv2.COLOR_BGR2RGB)
        h, w, ch = rgb_image.shape
        bytes_per_line = ch * w
        convert_to_Qt_format = QtGui.QImage(rgb_image.data, w, h, bytes_per_line, QtGui.QImage.Format_RGB888)
        p = convert_to_Qt_format.scaled(self.disply_width, self.display_height, Qt.KeepAspectRatio)
        return QPixmap.fromImage(p)
    
if __name__==&#34;__main__&#34;:
    app = QApplication(sys.argv)
    a = WebcamWindow()
    #a.start_recording()
    a.showMaximized()
    sys.exit(app.exec_())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.WebcamWindow.WebcamWindow"><code class="flex name class">
<span>class <span class="ident">WebcamWindow</span></span>
</code></dt>
<dd>
<div class="desc"><p>The WebcamWindow class is responsible for displaying a webcam feed in a GUI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WebcamWindow(QWidget):

    &#34;&#34;&#34;
    The WebcamWindow class is responsible for displaying a webcam feed in a GUI.
    &#34;&#34;&#34;

    startbuttonSignal = QtCore.pyqtSignal()
    calbuttonSignal = QtCore.pyqtSignal()

    def __init__(self):
        super().__init__()
        self.setWindowTitle(&#34;Qt live label demo&#34;)
        self.disply_width = 640
        self.display_height = 480
        self.no_webcam_text = &#34;No webcams connected&#34;
        self.permission_text = &#34;By pressing this button, you give permission to access your webcam. No actual footage will be stored.&#34;

        #Creates a button asking the user for permission to access their webcam
        self.permission_button = QPushButton(self.permission_text) 
        self.permission_button.clicked.connect(self.permitWebcamAccess)
        self.permission_button.setFixedSize(640, 150)

        #Create the label that holds the image
        self.image_label = QLabel(self)
        self.image_label.resize(self.disply_width, self.display_height)
        self.textLabel = QLabel(&#39;Webcam&#39;)

        #Create a vertical box layout and add the two labels
        vbox = QVBoxLayout()
        vbox.addWidget(self.permission_button, alignment=Qt.AlignCenter)
        vbox.addWidget(self.image_label)
        
        #self.image_label.hide()
        self.image_label.setAlignment(Qt.AlignCenter)
        self.calibration_text = &#34;Start calibration&#34;
        self.calibration_button = QPushButton(self.calibration_text)
        self.calibration_button.setFixedSize(640, 50)
        self.calibration_button.clicked.connect(self.calibration_button_clicked)
        self.calibration_button.setDisabled(True)
        vbox.addWidget(self.calibration_button, alignment=Qt.AlignHCenter)

        self.return_text = &#34;Return to start menu&#34;
        self.return_button = QPushButton(self.return_text)
        self.return_button.setFixedSize(640, 50)
        self.return_button.clicked.connect(self.return_button_clicked)
        vbox.addWidget(self.return_button, alignment=Qt.AlignHCenter)
        self.setLayout(vbox)

        #Create the video capture thread
        self.thread = Webcam()

    def calibration_button_clicked(self):
        &#34;&#34;&#34;Emits a signal when the calibration button is clicked.&#34;&#34;&#34;
        self.calbuttonSignal.emit()

    def return_button_clicked(self):
        &#34;&#34;&#34;Emits a signal when the return button is clicked.&#34;&#34;&#34;
        self.startbuttonSignal.emit()

    def permitWebcamAccess(self):
        &#34;&#34;&#34;Starts recording if the user gives permission to access their webcam.&#34;&#34;&#34;
        self.permission_button.hide()
        if self.thread.noWebcams() == False:
            self.calibration_button.setEnabled(True)
            self.start_recording()
        else:
            self.image_label.setText(self.no_webcam_text)

    def start_recording(self):
        #Connect its signal to the update_image slot
        self.thread.change_pixmap_signal.connect(self.update_image)
        #Start the thread
        self.thread.start()

    def closeEvent(self, event):
        self.thread.stop()
        event.accept()

    @pyqtSlot(np.ndarray)
    def update_image(self, cv_img):
        &#34;&#34;&#34;Updates the image_label with a new opencv image&#34;&#34;&#34;
        qt_img = self.convert_cv_qt(cv_img)
        self.image_label.setPixmap(qt_img)
    
    def convert_cv_qt(self, cv_img):
        &#34;&#34;&#34;Convert from an opencv image to QPixmap&#34;&#34;&#34;
        rgb_image = cv2.cvtColor(cv_img, cv2.COLOR_BGR2RGB)
        h, w, ch = rgb_image.shape
        bytes_per_line = ch * w
        convert_to_Qt_format = QtGui.QImage(rgb_image.data, w, h, bytes_per_line, QtGui.QImage.Format_RGB888)
        p = convert_to_Qt_format.scaled(self.disply_width, self.display_height, Qt.KeepAspectRatio)
        return QPixmap.fromImage(p)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.WebcamWindow.WebcamWindow.calbuttonSignal"><code class="name flex">
<span>def <span class="ident">calbuttonSignal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.WebcamWindow.WebcamWindow.calibration_button_clicked"><code class="name flex">
<span>def <span class="ident">calibration_button_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Emits a signal when the calibration button is clicked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calibration_button_clicked(self):
    &#34;&#34;&#34;Emits a signal when the calibration button is clicked.&#34;&#34;&#34;
    self.calbuttonSignal.emit()</code></pre>
</details>
</dd>
<dt id="src.WebcamWindow.WebcamWindow.closeEvent"><code class="name flex">
<span>def <span class="ident">closeEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"><p>closeEvent(self, QCloseEvent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeEvent(self, event):
    self.thread.stop()
    event.accept()</code></pre>
</details>
</dd>
<dt id="src.WebcamWindow.WebcamWindow.convert_cv_qt"><code class="name flex">
<span>def <span class="ident">convert_cv_qt</span></span>(<span>self, cv_img)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert from an opencv image to QPixmap</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_cv_qt(self, cv_img):
    &#34;&#34;&#34;Convert from an opencv image to QPixmap&#34;&#34;&#34;
    rgb_image = cv2.cvtColor(cv_img, cv2.COLOR_BGR2RGB)
    h, w, ch = rgb_image.shape
    bytes_per_line = ch * w
    convert_to_Qt_format = QtGui.QImage(rgb_image.data, w, h, bytes_per_line, QtGui.QImage.Format_RGB888)
    p = convert_to_Qt_format.scaled(self.disply_width, self.display_height, Qt.KeepAspectRatio)
    return QPixmap.fromImage(p)</code></pre>
</details>
</dd>
<dt id="src.WebcamWindow.WebcamWindow.permitWebcamAccess"><code class="name flex">
<span>def <span class="ident">permitWebcamAccess</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts recording if the user gives permission to access their webcam.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def permitWebcamAccess(self):
    &#34;&#34;&#34;Starts recording if the user gives permission to access their webcam.&#34;&#34;&#34;
    self.permission_button.hide()
    if self.thread.noWebcams() == False:
        self.calibration_button.setEnabled(True)
        self.start_recording()
    else:
        self.image_label.setText(self.no_webcam_text)</code></pre>
</details>
</dd>
<dt id="src.WebcamWindow.WebcamWindow.return_button_clicked"><code class="name flex">
<span>def <span class="ident">return_button_clicked</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Emits a signal when the return button is clicked.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_button_clicked(self):
    &#34;&#34;&#34;Emits a signal when the return button is clicked.&#34;&#34;&#34;
    self.startbuttonSignal.emit()</code></pre>
</details>
</dd>
<dt id="src.WebcamWindow.WebcamWindow.start_recording"><code class="name flex">
<span>def <span class="ident">start_recording</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_recording(self):
    #Connect its signal to the update_image slot
    self.thread.change_pixmap_signal.connect(self.update_image)
    #Start the thread
    self.thread.start()</code></pre>
</details>
</dd>
<dt id="src.WebcamWindow.WebcamWindow.startbuttonSignal"><code class="name flex">
<span>def <span class="ident">startbuttonSignal</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.WebcamWindow.WebcamWindow.update_image"><code class="name flex">
<span>def <span class="ident">update_image</span></span>(<span>self, cv_img)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the image_label with a new opencv image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pyqtSlot(np.ndarray)
def update_image(self, cv_img):
    &#34;&#34;&#34;Updates the image_label with a new opencv image&#34;&#34;&#34;
    qt_img = self.convert_cv_qt(cv_img)
    self.image_label.setPixmap(qt_img)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.WebcamWindow.WebcamWindow" href="#src.WebcamWindow.WebcamWindow">WebcamWindow</a></code></h4>
<ul class="">
<li><code><a title="src.WebcamWindow.WebcamWindow.calbuttonSignal" href="#src.WebcamWindow.WebcamWindow.calbuttonSignal">calbuttonSignal</a></code></li>
<li><code><a title="src.WebcamWindow.WebcamWindow.calibration_button_clicked" href="#src.WebcamWindow.WebcamWindow.calibration_button_clicked">calibration_button_clicked</a></code></li>
<li><code><a title="src.WebcamWindow.WebcamWindow.closeEvent" href="#src.WebcamWindow.WebcamWindow.closeEvent">closeEvent</a></code></li>
<li><code><a title="src.WebcamWindow.WebcamWindow.convert_cv_qt" href="#src.WebcamWindow.WebcamWindow.convert_cv_qt">convert_cv_qt</a></code></li>
<li><code><a title="src.WebcamWindow.WebcamWindow.permitWebcamAccess" href="#src.WebcamWindow.WebcamWindow.permitWebcamAccess">permitWebcamAccess</a></code></li>
<li><code><a title="src.WebcamWindow.WebcamWindow.return_button_clicked" href="#src.WebcamWindow.WebcamWindow.return_button_clicked">return_button_clicked</a></code></li>
<li><code><a title="src.WebcamWindow.WebcamWindow.start_recording" href="#src.WebcamWindow.WebcamWindow.start_recording">start_recording</a></code></li>
<li><code><a title="src.WebcamWindow.WebcamWindow.startbuttonSignal" href="#src.WebcamWindow.WebcamWindow.startbuttonSignal">startbuttonSignal</a></code></li>
<li><code><a title="src.WebcamWindow.WebcamWindow.update_image" href="#src.WebcamWindow.WebcamWindow.update_image">update_image</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>